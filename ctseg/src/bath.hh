/**
 * Module for storing bath/non-interacting diagrams (determinants).
 *
 * The central class here is `Bath`, which is composed of one or more `Blocks`,
 * which in turn wrap over `Determinant` instances: The UML diagrams looks like
 * this:
 *
 *         _________              _________                  _______________
 *        |         |1          *|         |1              1|               |
 *        |   Bath  |------------|  Block  |----------------|  Determinant  |
 *        |_________|            |_________|                |_______________|
 *            1|                   1|   1|     ______________       1|
 *             |                    |    |   1|              |       |
 *             |                    |    +----|  LinHybFunc  |       |
 *             |                    |         |______________|       |
 *       _____*|_____          ____*|_______                  ______*|_____
 *      |            |1      *|             |1              1|             |
 *      |  BathMove  |--------|  BlockMove  |----------------|   DetMove   |
 *      |____________|        |_____________|                |_____________|
 *
 *
 * Author: Markus Wallerberger
 */
#ifndef _BATH_HH
#define _BATH_HH

#include "block.hh"
#include "nfft.hh"

#include <vector>

// Forward declarations

template <typename ValueT> class Bath;

template <typename BathBlockMoveT> class BathMove;
template <typename ValueT> class BathInsertMove;
template <typename ValueT> class BathRemoveMove;

template <typename BlockEstimatorT> class GEstimator;
template <typename ValueT> class GtauEstimator;
template <typename ValueT> class GiwEstimator;

// Declarations

struct BlockPosition
{
    BlockPosition()
        : block_no(-1), block_pos(-1)
    { }

    BlockPosition(unsigned block_no, unsigned block_pos)
        : block_no(block_no), block_pos(block_pos)
    { }

    friend bool operator==(BlockPosition l, BlockPosition r)
    {
        return l.block_no == r.block_no && l.block_pos == r.block_pos;
    }

    friend bool operator!=(BlockPosition l, BlockPosition r) { return !(l == r); }

    unsigned block_no, block_pos;
};

struct BathOperator
{
    double tau;
    unsigned flavour;
};

/**
 * Stores a determinant of non-interacting propagators with a block structure.
 *
 * This class models a n-by-n matrix `M`, generated by some non-interacting
 * propagator `G`, evaluated for a set of `n` creation vertices (ctau,
 * cflavour) and annihilation vertices (atau, aflavour), as follows:
 *
 *          M[i, j] = G(cflavour[i], aflavour[j], ctau[i] - atau[j])
 *
 * Furthermore, time-ordering is enforced, i.e., `ctau[i] > ctau[j]` and
 * `atau[i] > atau[j]` whenever `i > j`.
 *
 * Most of the time `G` conserves a set of quantum numbers, which can be
 * mapped to a `G` being block-diagonal matrix in the flavours.  This
 * translates to a similar structure in the `M` matrix:
 *
 *                  M = sgn(RC) R diag(B_1, B_2, ..., B_n) C
 *
 * where `R` is a permutation matrix acting on the rows and `C` a permutation
 * of the columns mapping the block-diagonal matrix to the time-ordered form,
 * and sgn(RC) denotes the parity of that permutation.  This class thus stores
 * only a list of blocks plus two lookup arrays mapping the global index to
 * specific block numbers and block indices.
 */
template <typename ValueT = double>
class Bath
{
public:
    typedef ValueT Value;

public:
    /** Default constructor */
    Bath();

    /** Create bath instance from a set of blocks */
    Bath(const std::vector<Block<ValueT> >& blocks);

    /** Create bath instance from a set of blocks */
    Bath(const Block<ValueT> *blocks, unsigned nblocks);

    /** Return total number of flavours */
    unsigned nflavours() const { return nflavours_; }

    /** Return number of blocks */
    unsigned nblocks() const { return blocks_.size(); }

    /** Return number of flavour pairs allowed by block structure */
    unsigned npairs() const { return npairs_; }

    /** Return inverse temperature */
    double beta() const { return blocks_[0].beta(); }

    /** Return block */
    Block<ValueT> &block(unsigned i) { return blocks_[i]; }

    /** Return block */
    const Block<ValueT> &block(unsigned i) const { return blocks_[i]; }

    /** Return flavour offset for a block */
    unsigned flavour_offset(unsigned i) const { return flavour_offset_[i]; }

    /** Return flavour offset for a block */
    unsigned pair_offset(unsigned i) const { return pair_offset_[i]; }

    /** Return creation operator/row vertex */
    BathOperator coper(unsigned index) const;

    /** Return creation operator/column vertex */
    BathOperator aoper(unsigned index) const;

    /** Retrieve block number and block index for given creator */
    const BlockPosition &clookup(unsigned i) const { return clookup_[i]; }

    /** Retrieve block number and block index for given annihilator */
    const BlockPosition &alookup(unsigned i) const { return alookup_[i]; }

    /** Retrieve global index for block number and position of creator */
    unsigned crlookup(BlockPosition pos) const;

    /** Retrieve global index for block number and position of annihilator */
    unsigned arlookup(BlockPosition pos) const;

    /** Verify internal consistency of instance */
    void verify(bool recursive = false, double tol = 1e-6) const;

    /** Return determinant of the diagram */
    ValueT weight() const { return weight_; }

    /** Return total order of the diagram (size of determinant) */
    unsigned order() const { return alookup_.size(); }

    /** Find position where a new row/column vertex with tau value would go */
    unsigned find(double tau, bool effect) const;

    /** Recalculate sign of the permutation arrays R and C */
    int calc_perm_sign() const;

    /** Recalculate determinant from scratch using only vertex infos */
    ValueT calc_weight() const;

protected:
    void analyse_blocks();

    typedef typename std::vector<Block<ValueT> >::const_iterator bciter;

    std::vector<Block<ValueT> > blocks_;
    std::vector<unsigned> block_for_flavour_, flavour_offset_, pair_offset_;
    std::vector<BlockPosition> clookup_, alookup_;
    unsigned nflavours_, npairs_;
    ValueT weight_;

    friend class BathInsertMove<ValueT>;
    friend class BathRemoveMove<ValueT>;

    friend class GEstimator< GtauBlockEstimator<ValueT> >;
    friend class GEstimator< GiwBlockEstimator<ValueT> >;
    friend class GtauEstimator<ValueT>;
    friend class GiwEstimator<ValueT>;
};

/**
 * Base class of bath move generators.
 *
 * This class provides the base class for rank-k updates on the bath, i.e., the
 * modification of k row and column vertices in the determinant.  Since there
 * is a block structure, each such move can usually be decomposed into an
 * update of the lookup arrays, and one or more simultaneous block moves.
 */
template <typename BlockMoveT>
class BathMove
{
public:
    typedef typename BlockMoveT::Value Value;

public:
    BathMove();

    BathMove(Bath<Value> &target, unsigned max_rank);

    unsigned max_rank() const { return max_rank_; }

    unsigned rank() const { return rank_; }

    const Bath<Value> &target() const { return *target_; }

    Value ratio() const { return ratio_; }

    bool hard_reject() const { return hard_reject_; }

    int sign_change() const { assert(sign_change_); return sign_change_; }

    const BlockMoveT &block_move(unsigned i) const { return block_moves_[i]; }

protected:
    Bath<Value> *target_;
    std::vector<BlockMoveT> block_moves_;
    unsigned rank_, max_rank_;
    bool hard_reject_;
    Value ratio_;
    int sign_change_;
};

/**
 * Generate moves that insert k vertices into the diagram.
 *
 * The creation and annihilation operators must each be sorted by imaginary
 * time (use `verify_args()` to check for this).
 */
template <typename ValueT = double>
class BathInsertMove
        : public BathMove< BlockAppendMove<ValueT> >
{
public:
    typedef ValueT Value;

public:
    BathInsertMove();

    BathInsertMove(Bath<ValueT> &target, unsigned max_rank);

    void verify_args(unsigned rank, const double *ctau,
                     const unsigned *cflavour, const double *atau,
                     const unsigned *aflavour) const;

    void propose(unsigned rank, double *ctau, unsigned *cflavour,
                 double *atau, unsigned *aflavour);

    void accept();

    const unsigned *cindex() const { return &cindex_[0]; }

    const unsigned *aindex() const { return &aindex_[0]; }

protected:
    std::vector<BlockOperator> coper_, aoper_;
    std::vector<unsigned> cblock_rank_, ablock_rank_;
    unsigned block_perm_;

    std::vector<unsigned> cindex_, aindex_;
    std::vector<BlockPosition> clookup_, alookup_;
};

/**
 * Generate moves that remove k vertices from the diagram.
 *
 * The creation and annihilation indices must each be sorted.
 */
template <typename ValueT = double>
class BathRemoveMove
        : public BathMove< BlockRemoveMove<ValueT> >
{
public:
    typedef ValueT Value;

public:
    BathRemoveMove();

    BathRemoveMove(Bath<ValueT> &target, unsigned max_rank);

    void verify_args(unsigned rank, const unsigned *cindex,
                     const unsigned *aindex) const;

    void propose(unsigned rank, unsigned *cindex, unsigned *aindex);

    void accept();

    const unsigned *cindex() const { return &cindex_[0]; }

    const unsigned *aindex() const { return &aindex_[0]; }

protected:
    std::vector<unsigned> cblock_, ablock_;
    std::vector<unsigned> blocks_;
    unsigned num_perms_, num_blocks_;
    unsigned *cindex_, *aindex_;
    std::vector<unsigned> crepl_index_, crepl_repl_, arepl_index_, arepl_repl_;
};


template <typename ValueT = double>
class BathRecompute
{
public:
    BathRecompute() { }

    BathRecompute(Bath<ValueT> &target);

    void propose();

    void accept();

    double error() const { return error_; }

protected:
    std::vector< BlockRecompute<ValueT> > block_recomps_;
    double error_;
};


template <typename ValueT>
class GtauEstimator
{
public:
    GtauEstimator(const Bath<ValueT> &source, unsigned ntau_bins);

    const Bath<ValueT> &source() const { return *source_; }

    void estimate(ValueT *accum, ValueT weight);

    void postprocess(ValueT *result, const ValueT *accum, ValueT sum_weights);

    unsigned accum_size() const { return accum_size_; }

    unsigned result_size() const { return result_size_; }

    unsigned ntau() const { return blocks_[0].ntau(); }

protected:
    const Bath<ValueT> *source_;
    std::vector< GtauBlockEstimator<ValueT> > blocks_;
    std::vector<unsigned> accum_offset_, result_offset_;
    unsigned accum_size_, result_size_;
};

/**
 * Estimates the dressed propagator in frequency as collection of block
 * estimators.
 */
template <typename ValueT>
class GiwEstimator
{
public:
    typedef const std::complex<double>* ConstAccumulatorT;
    typedef std::complex<double>* AccumulatorT;
    typedef std::complex<double>* ResultT;

public:
    GiwEstimator(const Bath<ValueT> &source, unsigned niwf, bool use_nfft);

    const Bath<ValueT> &source() const { return *source_; }

    void estimate(AccumulatorT accum, ValueT weight);

    void postprocess(ResultT result, AccumulatorT accum, ValueT sum_weights);

    unsigned accum_size() const { return accum_size_; }

    unsigned result_size() const { return result_size_; }

    unsigned niwf() const { return blocks_[0].niwf(); }

protected:
    const Bath<ValueT> *source_;
    std::vector< GiwBlockEstimator<ValueT> > blocks_;
    std::vector<unsigned> accum_offset_, result_offset_;
    unsigned accum_size_, result_size_;
};

/**
 * Estimates the two-particle Green's function in one bosonic (`iw`) and two
 * fermionic Matsubara frequencies (`iv`, `ivp`), defined in the particle-hole
 * picture as:
 *
 *     G(iw, iv, ivp) = int d**4 t G(tau_1, tau_2, tau_3, tau_4)
 *           exp(iv*(tau_1 - tau_2) + ivp*(tau_3 - tau_4) + iw*(tau_1 - tau_4))
 *
 * where the Green's function in imaginary time is defined as:
 *
 *     G_ABCD(tau_1, tau_2, tau_3, tau_4) =
 *                      < c_A(tau_1) c+_B(tau_2) c_C(tau_3) c_D(tau_4) >
 *
 */
template <typename ValueT>
class G4iwEstimator
{
public:
    typedef const std::complex<double>* ConstAccumulatorT;
    typedef std::complex<double>* AccumulatorT;
    typedef std::complex<double>* ResultT;

public:
    G4iwEstimator(const Bath<ValueT> &source, unsigned niwf, unsigned niwb,
                  bool use_nfft);

    const Bath<ValueT> &source() const { return *source_; }

    void estimate(AccumulatorT accum, ValueT weight, const ValueT *hartree = NULL);

    void postprocess(ResultT result, ConstAccumulatorT accum, ValueT sum_weights);

    unsigned accum_size() const
    {
        // The factor 2 is for straight and crossing term
        return 2 * source().npairs() * source().npairs()
               * 4 * niwf_ * niwf_ * (2 * niwb_ - 1);
    }

    unsigned result_size() const { return accum_size(); }

    unsigned niwf() const { return niwf_; }

    unsigned niwb() const { return niwb_; }

protected:
    void perform_ndft_2d(const ValueT *hartree);

    void assemble(AccumulatorT accum, ValueT weight);

    unsigned niwf_, niwb_;
    const Bath<ValueT> *source_;
    AdjointNDFT plan_;
};

#ifndef SWIG
    #include "bath.tcc"
#endif

#endif /* _BATH_HH */
